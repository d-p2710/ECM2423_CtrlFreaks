import random
import string

"""KNOWN ISSUES:
    - 1. The word placement is not rndom enough with a variety of directions
    - 2. Typically chooses Bootom Left -> Top Right direction
    - 3. Does not have any horizontal & vertical
    
    TODO:
    - 1. Ensure horizontal and vertical placements exits
    - 2. Ensure the word placement is random enough with a variety of directions
    - 3. Ensure the word placement occurs at differnt start points instead of always from col 1 & 2
    
    HOW: 
    - 1. Force the first x words to be placed in a specific direction 
    - 2. Randomise the starting index (ensuring word placement would be within bounds)
    - 3. Then call suggest_coordinates to get the next word placement
         This should make direction of subsequrnt word placements more randomsied
"""

class Word:
    def __init__(self, word, clue, direction=None):
        self.word = word
        self.clue = clue
        self.direction=direction

class WordSearchGenerator:
    def __init__(self, cols, rows, empty='-', maxloops=2000, available_words=[]):
        self.cols = cols
        self.rows = rows
        self.empty = empty
        self.maxloops = maxloops # maximum loops allowed in the generation process
        self.available_words = available_words # list of âˆ€. words that can potentially be placed in the crossword
        self.randomise_word_list()
        self.current_word_list = []
        self.clear_grid()
        self.debug = 0
        
    def clear_grid(self):
        """Initialize grid and fill with empty character."""
        self.grid = [[self.empty for _ in range(self.cols)] for _ in range(self.rows)]

    def randomise_word_list(self):
        """Randomised to add variation in generation process & enhance difficulty"""
        random.seed()
        self.available_words = [Word(word.word, word.clue) if isinstance(word, Word) else Word(word[0], word[1]) for word in self.available_words]
        random.shuffle(self.available_words)
        self.available_words.sort(key=lambda word: len(word.word), reverse=True)
        
        
    def suggest_coordinates(self, word):
        coordlist = []
        word_length = len(word.word)

        for row in range(self.rows):
            for col in range(self.cols):
                for direction in range(8):  # Iterate over all directions
                    # Calculate end coordinates based on direction
                    if direction == 0:  # Horizontal forward
                        end_row, end_col = row, col + word_length - 1
                    elif direction == 1:  # Horizontal backward
                        end_row, end_col = row, col - word_length + 1
                    elif direction == 2:  # Vertical forward
                        end_row, end_col = row + word_length - 1, col
                    elif direction == 3:  # Vertical backward
                        end_row, end_col = row - word_length + 1, col
                    elif direction == 4:  # Diagonal top-left to bottom-right
                        end_row, end_col = row + word_length - 1, col + word_length - 1
                    elif direction == 5:  # Diagonal bottom-right to top-left
                        end_row, end_col = row - word_length + 1, col - word_length + 1
                    elif direction == 6:  # Diagonal top-right to bottom-left
                        end_row, end_col = row + word_length - 1, col - word_length + 1
                    elif direction == 7:  # Diagonal bottom-left to top-right
                        end_row, end_col = row - word_length + 1, col + word_length - 1
                        
                 # Check if word fits within bounds without wrapping
                if (0 <= end_row < self.rows and 0 <= end_col < self.cols) and \
                   (0 <= row < self.rows and 0 <= col < self.cols):
                    # Reverse the word for backward directions
                    reversed_word = word.word[::-1] if direction in [1, 3, 5, 7] else word
                    # Calculate fitness score using calculate_fit_score
                    fitness = self.calculate_fit_score(reversed_word, col, row, direction)
                    coordlist.append((col, row, direction, fitness, reversed_word))
        return coordlist
    
    def check_if_cell_clear(self, col, row):
        """Check if the specified cell in the grid is clear (empty)."""
        try:
            cell_value = self.grid[row][col]
            return cell_value == self.empty
        except IndexError:
            return False
        
    def get_cell(self, col, row):
        return self.grid[row-1][col-1]
 
    def calculate_fit_score(self, word, col, row, direction):
        """
        Determines the fitness score for placing the word at a given position and direction.
        If the grid slot is empty or contains the same letter as the word, assign a score of 1.
        If there is a conflict, assign a score of 0.
        """
        if col < 1 or row < 1:
            return 0

        # give score a standard value of 1, will override with 0 if collisions detected
        count, score = 1, 1
        for letter in word:
            try:
                active_cell = self.get_cell(col, row)
            except IndexError:
                return 0

            if active_cell == self.empty or active_cell == letter:
                pass
            else:
                return 0

            if active_cell == letter:
                score += 1

            if direction in [2, 3]:  # Vertical
                # Check surroundings
                if active_cell != letter:  # Don't check surroundings if cross point
                    if not self.check_if_cell_clear(col + 1, row):  # Check right cell
                        return 0

                    if not self.check_if_cell_clear(col - 1, row):  # Check left cell
                        return 0

                if count == 1:  # Check top cell only on first letter
                    if not self.check_if_cell_clear(col, row - 1):
                        return 0

                if count == len(word.word):  # Check bottom cell only on last letter
                    if not self.check_if_cell_clear(col, row + 1):
                        return 0
            elif direction in [4, 5, 6, 7]:  # Diagonal
                # Check surroundings
                if active_cell != letter:  # Don't check surroundings if cross point
                    if not self.check_if_cell_clear(col + 1, row + 1):  # Check bottom-right cell
                        return 0

                    if not self.check_if_cell_clear(col - 1, row - 1):  # Check top-left cell
                        return 0

                    if not self.check_if_cell_clear(col - 1, row + 1):  # Check bottom-left cell
                        return 0

                    if not self.check_if_cell_clear(col + 1, row - 1):  # Check top-right cell
                        return 0

            else:  # Horizontal
                # Check surroundings
                if active_cell != letter:  # Don't check surroundings if cross point
                    if not self.check_if_cell_clear(col, row - 1):  # Check top cell
                        return 0

                    if not self.check_if_cell_clear(col, row + 1):  # Check bottom cell
                        return 0

                if count == 1:  # Check left cell only on first letter
                    if not self.check_if_cell_clear(col - 1, row):
                        return 0

                if count == len(word):  # Check right cell only on last letter
                    if not self.check_if_cell_clear(col + 1, row):
                        return 0

            if direction in [2, 4, 6]:  # Progress to next letter and position (vertical/diagonal)
                row += 1
            elif direction in [5, 7]:
                row -= 1
            else:  # Progress to next letter and position (horizontal)
                col += 1

            count += 1

        return score


    
    def sort_coordinates(self, coordinates):
        """based off of the score of each word, the coordinates are sorted from highest to lowest score. If two words have the same score they will be sorted by the length of the word."""
        return sorted(coordinates, key=lambda x: (-x[3], len(x[4])))
    
    def set_word(self, col, row, direction, word, force=False):
        """Set word in the grid, and add word to word list."""
        if force:
            word.col = col
            word.row = row
            word.direction = direction
            self.current_word_list.append(word)

            for letter in word.word:
                self.set_cell(col, row, letter)
                if direction == 0:  # Horizontal forward
                    col += 1
                elif direction == 1:  # Horizontal backward
                    col -= 1
                elif direction == 2:  # Vertical forward
                    row += 1
                elif direction == 3:  # Vertical backward
                    row -= 1
                elif direction == 4:  # Diagonal top-left to bottom-right
                    row += 1
                    col += 1
                elif direction == 5:  # Diagonal bottom-right to top-left
                    row -= 1
                    col -= 1
                elif direction == 6:  # Diagonal top-right to bottom-left
                    row += 1
                    col -= 1
                elif direction == 7:  # Diagonal bottom-left to top-right
                    row -= 1
                    col += 1
        return

    
    def set_cell(self, col, row, letter):
        """Set cell in grid."""
        self.grid[row][col] = letter
    
    def solution(self):
        """Return solution grid."""
        outStr = ""
        for r in range(self.rows):
            for c in self.grid[r]:
                outStr += '%s ' % c
            outStr += '\n'
        return outStr
 
    def word_find(self):
        """Return solution grid."""
        outStr = ""
        for r in range(self.rows):
            for c in self.grid[r]:
                if c == self.empty:
                    outStr += '%s ' % string.ascii_lowercase[random.randint(0,len(string.ascii_lowercase)-1)]
                else:
                    outStr += '%s ' % c
            outStr += '\n'
        return outStr
    
    def word_bank(self):
        """prints the word bank"""
        outStr = ''
        temp_list = self.current_word_list.copy()
        # randomize word list
        random.shuffle(temp_list)
        for word in temp_list:
            outStr += '%s\n' % word.word
        return outStr

    
    def legend(self):
        """prints the legend"""
        outStr = ''
        for word in self.current_word_list:
            outStr += '(%d,%d): %s\n' % (word.col, word.row, word.clue)
        return outStr
    
    def generate_wordsearch(self):
        """generates a wordsearch"""
        for word in self.available_words[:5]:
            self.initial_build(word)
        
        for word in self.available_words[3:]:
            coordinates=self.suggest_coordinates(word)
            sorted_coordinates=self.sort_coordinates(coordinates)
            coord=sorted_coordinates[0]
            self.set_word(coord[0], coord[1], coord[2], word, force=True)
        
        return self
    
    # def initial_build(self, word):
    #     """Force the first 3 words to be placed in a specific direction"""
    #     fit = False
    #     count = 0
    #     coordlist = self.suggest_coordinates(word)
 
    #     while not fit and count < self.maxloops:
    #         # this is the first word: the seed
    #         if len(self.current_word_list) == 0:
    #             # top left seed of longest word yields best results (maybe override)
    #             vertical, col, row = random.randrange(0, 2), 1, 1
    #             if self.calculate_fit_score(col, row, vertical, word):
    #                 fit = True
    #                 self.set_word(col, row, vertical, word, force=True)
                
    #         else:
    #             try:
    #                 col, row, vertical = coordlist[count][0], coordlist[count][1], coordlist[count][2]
    #             # no more cordinates, stop trying to fit
    #             except IndexError:
    #                 return
 
    #             # already filtered these out, but double check
    #             if coordlist[count][4]:
    #                 fit = True
    #                 self.set_word(col, row, vertical, word, force=True)
 
    #         count += 1

    #     return 
    
    def initial_build(self, word):
        """Force the first 3 words to be placed in a specific direction"""
        fit = False
        count = 0
        coordlist = self.suggest_coordinates(word)

        while not fit and count < self.maxloops:
            # this is the first word: the seed
            if len(self.current_word_list) == 0:
                # top left seed of longest word yields best results (maybe override)
                vertical, col, row = random.randrange(0, 2), 1, 1
                if self.calculate_fit_score(word.word, col, row, vertical):
                    fit = True
                    self.set_word(col, row, vertical, word, force=True)

            else:
                try:
                    col, row, vertical = coordlist[count][0], coordlist[count][1], coordlist[count][2]
                # no more coordinates, stop trying to fit
                except IndexError:
                    return

                # already filtered these out, but double check
                if coordlist[count][3]:
                    fit = True
                    self.set_word(col, row, vertical, word, force=True)

            count += 1

    
    def print_word_search(self):
        """prints the word search"""
        print(self.solution())
        return
    
    

# Example usage:

# Define some words
words = [
    ("python", "A programming language"),
    ("code", "To write instructions for a computer"),
    ("algorithm", "A set of rules to be followed in calculations"),
    ("variable", "A data item that may take on more than one value"),
    ("debug", "Identify and remove errors from computer hardware or software"),
    ("inheritance", "The practice of passing on property, titles, debts, etc., to a successor"),
    ("iteration", "The repetition of a process or utterance"),
    ("compilation", "The action or process of producing something, especially a list or book, by assembling information collected from other sources"),
    ("decomposition", "The process of breaking down complex objects or systems into simpler parts"),
    ("heuristic", "Enabling a person to discover or learn something for themselves"),
    ("implementation", "The process of putting a decision or plan into effect"),
    ("iteration", "The repetition of a process or utterance"),
]

# Create a WordSearchGenerator object
word_search_generator = WordSearchGenerator(cols=15, rows=15, available_words=words)

# Generate the word search
word_search_generator.generate_wordsearch()

# Print the word search
word_search_generator.print_word_search()

# Print the word bank
print("Word Bank:")
print(word_search_generator.word_bank())

# Print the legend
print("Legend:")
print(word_search_generator.legend())
print(word_search_generator.word_find())